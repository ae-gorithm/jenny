# 📅 2025-07-15 TIL

### 📖 1. 오늘 배운 내용

BOJ 2096번 문제 (내려가기)를 풀이하면서 2차원 배열을 입력받아 처리하는 기능, 각 위치에서 가능한 다음 위치 계산 로직, 최대/최소 점수 동적 계획법 계산 및 출력 기능을 구현했습니다. 기존 디버깅용 `print` 문을 제거하고 예외 처리 로직 없이 직접 응답 처리 방식을 개선했습니다.

### 📚 2. 개념 정리

*   **동적 계획법 (Dynamic Programming):**  복잡한 문제를 작은 부분 문제로 나누어 해결하고, 부분 문제의 해를 저장하여 중복 계산을 피하는 알고리즘 기법입니다.  최대/최소 점수 계산에 적합합니다.
*   **2차원 배열:**  행렬 형태로 데이터를 표현하는 자료구조입니다.  이 문제에서는 각 위치의 정보를 저장하는 데 사용됩니다.
*   **입력 처리:**  2차원 배열 형태로 입력받아 각 요소에 값을 할당하는 과정입니다.
*   **최적화:**  최대/최소 점수를 효율적으로 계산하기 위해 DP를 활용합니다.

### 🤔 3. 해당 개념이 필요한 이유

DP는 점수 계산이 복잡하고 중복되는 부분이 많아 효율적인 해결 방법입니다. 2차원 배열은 문제의 상태를 표현하는 데 필수적이며, 각 위치에서 가능한 다음 위치를 계산하는 로직은 문제의 핵심 규칙을 구현합니다.  최적화는 주어진 제약 조건 하에서 가장 좋은 결과를 얻기 위해 필요합니다.

### 💡 4. 개념을 활용하는 방법

1.  **문제 분석:** 문제의 규칙과 제약 조건을 파악합니다.
2.  **상태 정의:**  각 위치의 점수를 상태로 정의합니다.
3.  **DP 테이블 구성:**  상태를 나타내는 2차원 배열을 구성합니다.
4.  **DP 관계 정의:**  각 상태에서 다음 상태로 이동하는 규칙을 정의합니다.
5.  **DP 테이블 채우기:**  DP 관계를 이용하여 DP 테이블을 채웁니다.
6.  **최적값 계산:**  DP 테이블에서 최대/최소 점수를 계산합니다.
7.  **결과 출력:**  계산된 최대/최소 점수를 출력합니다.

### 🛠️ 5. 문제 해결 과정

1.  입력받은 2차원 배열을 이용하여 각 위치의 정보를 저장합니다.
2.  각 위치에서 가능한 다음 위치를 계산하는 함수를 구현합니다.
3.  DP 테이블을 초기화합니다.
4.  DP 관계를 이용하여 DP 테이블을 채웁니다.  `dp[i][j]`는 `i`번째 위치에서 `j`번째 방향으로 이동했을 때 얻을 수 있는 최대/최소 점수를 나타냅니다.
5.  DP 테이블에서 최대/최소 점수를 계산합니다.
6.  결과를 출력합니다.

### ✍️ 6. 하루 회고

DP를 활용하여 문제를 해결하는 과정이 복잡했지만, 문제의 규칙을 명확히 이해하고 상태를 정의하는 데 집중하면 효율적으로 해결할 수 있었습니다.  디버깅용 `print` 문을 제거하는 과정에서 코드의 가독성을 높이는 것이 중요함을 느꼈습니다.  예외 처리 없이 직접 응답 처리 방식을 개선하여 문제의 제약 조건을 만족하는 솔루션을 만들었습니다.